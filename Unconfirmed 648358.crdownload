#!/usr/bin/env python
# coding: utf-8

# In[2]:


#Project Timeline
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import datetime
# Sample data 
tasks = ["Task A", "Task B", "Task C", "Task D"]
start_dates = ["2024-02-01", "2024-02-05", "2024-02-10", "2024-02-15"]
end_dates = ["2024-02-07", "2024-02-15", "2024-02-18", "2024-02-25"]
# Convert date strings to datetime objects
start_dates = [datetime.datetime.strptime(date, "%Y-%m-%d") for date in start_dates]
end_dates = [datetime.datetime.strptime(date, "%Y-%m-%d") for date in end_dates]
# Create a figure and plot the timeline
fig, ax = plt.subplots(figsize=(10, 5)) #width and height 
for i, task in enumerate(tasks):
    ax.barh(task, width=(end_dates[i] - start_dates[i]).days, left=start_dates[i], label=task)
# Customize the x-axis to display dates
ax.xaxis_date()
date_format = mdates.DateFormatter("%Y-%m-%d")
ax.xaxis.set_major_formatter(date_format)
# Customize the plot
ax.set_xlabel("Timeline")
ax.set_title("Project Timeline")
ax.legend()
# Display the plot
plt.show()



# In[2]:


#Set up simulation environment
import simpy
import pandas as pd

# Read data from the provided CSV file
data = pd.read_csv('simulation5.csv')

class MiningSection:
    def __init__(self, env, name, length, width, depth):
        self.env = env
        self.name = name
        self.length = length
        self.width = width
        self.depth = depth
        self.equipment_queue = simpy.Store(env)

    def move_equipment(self, equipment):
        yield self.env.timeout(1)  # Time to move equipment within the section

def equipment_process(env, equipment, section):
    section_name = section.name
    print(f"Equipment {equipment['equipment']} enters {section_name} section at {get_formatted_time(env.now)}")
    yield env.process(section.move_equipment(equipment))
    print(f"Equipment {equipment['equipment']} exits {section_name} section at {get_formatted_time(env.now)}")

def get_formatted_time(simulation_time):
    # Convert simulation time to 12-hour format
    formatted_time = simulation_time % 24
    am_pm = 'AM' if 0 <= formatted_time < 12 else 'PM'
    formatted_time = formatted_time % 12 if formatted_time % 12 != 0 else 12
    return f"{int(formatted_time)}{am_pm}"

def setup_simulation(env, data):
    print("Available columns in the DataFrame:", data.columns)
    
    # Skip rows where 'section' column has 'nan' values
    valid_data = data.dropna(subset=['section'])
    
    for _, equipment in valid_data.iterrows():
        section = MiningSection(env, equipment['section'], equipment['length'], equipment['width'], equipment['depth'])
        env.process(equipment_process(env, equipment, section))

# Create simulation environment
env = simpy.Environment()

# Setup simulation with provided data
setup_simulation(env, data)

# Run the simulation until 5 PM
env.run(until=17)


# In[4]:


# Map data schema relationships
import networkx as nx #for graph representation
import matplotlib.pyplot as plt
# Create a directed graph
G = nx.DiGraph()
# Add nodes for classes and attributes
G.add_node('MiningSection')
G.add_node('env')
G.add_node('name')
G.add_node('length')
G.add_node('width')
G.add_node('depth')
G.add_node('equipment_queue')
G.add_node('move_equipment')
G.add_node('equipment_process')
G.add_node('get_formatted_time')
G.add_node('simulation_time')
# Add edges to represent relationships
G.add_edges_from([('MiningSection', 'env'), ('MiningSection', 'name'), ('MiningSection', 'length'),
                  ('MiningSection', 'width'), ('MiningSection', 'depth'), ('MiningSection', 'equipment_queue'),
                  ('MiningSection', 'move_equipment'), ('move_equipment', 'equipment'), ('env', 'timeout'),
                  ('equipment_process', 'section'), ('equipment_process', 'equipment'),
                  ('get_formatted_time', 'simulation_time')])
# Visualize the graph
pos = nx.spring_layout(G)
nx.draw(G, pos, with_labels=True, font_weight='bold', node_color='skyblue', node_size=2000, arrowsize=20)
plt.show()


# In[6]:


#Build geological models
import matplotlib.pyplot as plt
import pandas as pd
# Read data from the provided CSV file
data = pd.read_csv('simulation5.csv')
class MiningSection:
    def __init__(self, env, name, length, width, depth):
        self.env = env
        self.name = name
        self.length = length
        self.width = width
        self.depth = depth
        self.equipment_queue = simpy.Store(env)
    def move_equipment(self, equipment):
        yield self.env.timeout(1)  # Time to move equipment within the section
def visualize_geological_layers(data):
    # Drop rows where 'depth' column has NaN values
    data = data.dropna(subset=['depth'])
    fig, ax = plt.subplots(figsize=(8, 6))
    for _, section in data.iterrows():
        depth_start = section['depth']
        depth_end = depth_start + section['length']
        width = section['width']
        ax.fill_betweenx(y=[depth_start, depth_end], x1=0, x2=width, label=section['section'])
    ax.set_xlabel('Width')
    ax.set_ylabel('Depth')
    ax.set_title('Geological Layers')
    ax.legend()
    plt.show()
# Visualize geological layers based on the provided data
visualize_geological_layers(data)



# In[7]:


#Construct equipment objects
import pandas as pd
class Equipment:
    def __init__(self, name, type_of_equipment, capacity, power, section, type_of_section, depth, length, width, equipment, utilization, mtbf, mttr):
        self.name = name
        self.type_of_equipment = type_of_equipment
        self.capacity = capacity
        self.power = power
        self.section = section
        self.type_of_section = type_of_section
        self.depth = depth
        self.length = length
        self.width = width
        self.equipment = equipment
        self.utilization = utilization
        self.mtbf = mtbf
        self.mttr = mttr
def construct_objects(data):
    equipment_objects = []
    expected_attributes = ["name", "Type of equipment", "Capacity", "Power", "Section", "Type of section", "Depth", "Length", "Width", "Equipment", "Utilization", "MTBF", "MTTR"]
    for _, item in data.iterrows():
        item_dict = {attr.replace(" ", "_").lower(): item.get(attr, None) for attr in expected_attributes}
        equipment_objects.append(Equipment(**item_dict))
    return equipment_objects
def create_timeline(equipment_objects):
    timeline = {}
    for equipment in equipment_objects:
        section_key = f"{equipment.section} {equipment.type_of_section}"
        if section_key not in timeline:
            timeline[section_key] = []
        timeline[section_key].append({
            "name": equipment.name,
            "type_of_equipment": equipment.type_of_equipment,
            "capacity": equipment.capacity,
            "power": equipment.power,
            "depth": equipment.depth,
            "length": equipment.length,
            "width": equipment.width,
            "equipment": equipment.equipment,
            "utilization": equipment.utilization,
            "mtbf": equipment.mtbf,
            "mttr": equipment.mttr
        })
    return timeline
# Read CSV file
file_path = 'simulation5.csv'
data = pd.read_csv(file_path)
# Assign equipment names based on the 'Equipment' column
data['name'] = data['Equipment']
# Construct equipment objects
equipment_objects = construct_objects(data)
timeline = create_timeline(equipment_objects)
# Display the timeline
for section, equipment_list in timeline.items():
    print(f"{section}:\n")
    for equipment in equipment_list:
        print(f"- {equipment['name']}: Type {equipment['type_of_equipment']}, Capacity {equipment['capacity']}, Power {equipment['power']}, Utilization {equipment['utilization']}, MTBF {equipment['mtbf']}, MTTR {equipment['mttr']}")
    print("\n")


# In[ ]:




